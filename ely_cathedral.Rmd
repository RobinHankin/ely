---
title: "ely_cathedral_and_caldecote"
output: html_document
date: "2022-11-09"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## A remarkable geographical coincidence

First we define the Haversine function and use it to calculate great circle distances, `gcd`()`:

```{r definehaversinefunc}
hav <- function(dphi,phis,phif,dlam){ #  Haversine formula 
  2*asin(sqrt(
                (sin(dphi/2))^2 + cos(phis)*cos(phif)*(sin(dlam/2))^2
                ))
}

```{r definegcd}
gcd <- function(pos1,pos2){  # great circle distance
  dphi <- pos1[1]-pos2[1]
  phis <- pos1[1]
  phif <- pos2[1]
  dlam <- pos1[2]-pos2[2]
  hav(dphi,phis,phif,dlam)
}
```

Now the latitude and longitude of three positions:  my house (`RH`), Ely Cathedral (`EC`) and Ted's house (`LO`, Little Ouse):

```{r latandlong}
RH  <- c(phi=52.206275, lambda= -0.025892)  # deg N & E (front door)
RH  <- c(phi=52.206367, lambda=  -0.025846)
EC  <- c(phi=52.398657, lambda=  0.263873)  # Centre of Ely Cath octagon
LO  <- c(phi=52.476138, lambda=  0.381944)  # Chimneypot on my house at Little Ouse
```

```{r}
LL <- rbind(RH,EC,LO)
LL
plot(LL[c(1,2,3,1),2:1],asp=1,type='b',xlab="longitude",ylab="latitude")
for(i in 1:3){text(LL[i,2],LL[i,1],rownames(LL)[i],pos=4)}
```


```{r}
RH <- RH*pi/180  # Convert to radians
EC <- EC*pi/180
LO <- LO*pi/180
```

Distances, in radians:

```{r}
EC_LO <- gcd(EC,LO)
LO_RH <- gcd(LO,RH)
RH_EC <- gcd(RH,EC)
```

Giving

```{r}
gc_dist <- c(EC_LO,LO_RH,RH_EC)
names(gc_dist) <- c("EC_LO","LO_RH","RH_EC")
gc_dist
```
}

Calculate the sines and cosines:

```{r}
sin_a <- sin(RH_EC)
sin_b <- sin(RH_LO)
sin_c <- sin(EC_LO)

cos_a <- cos(RH_EC)
cos_b <- cos(RH_LO)
cos_c <- cos(EC_LO)

RADIUS_OF_EARTH <- 6378000 
```

Finally, use the Haversine formula to calculated the angles of the triangle:


```{r}
angle1 <- acos((cos_c-cos_a*cos_b)/(sin_a*sin_b))
angle2 <- acos((cos_a-cos_b*cos_c)/(sin_b*sin_c))
angle3 <- acos((cos_b-cos_c*cos_a)/(sin_c*sin_a))

angles <- c(angle1,angle2,angle3)
names(angles) <-  c("EC_RH_LO","LO_EC_RH","EC_RH_LO")
angles
```

Observe how small two of the angle are, which was Ted's original observation.  We can interpret the
smallness of the angles in two ways.  Firstly:

```{r}
dist <- RADIUS_OF_EARTH*gcd(LO,RH)*c(angle1,angle2)
dist
```

Above, the elements of `dist` show the distance from RH-EC (produced) to LO, and LO-EC (produced) to RH, in meters.  See how small these values are!  And secondly we can calculate the excess angle:

```{r}
(E <- sum(angles) - pi)
(area <- E*RADIUS_OF_EARTH^2)
```




Now, introduce an ellipsoidal earth:

```{r}
lambert_distance <- function(p1,p2){
  f <- 1/298.257223563    # WGS-84

  s <- gcd(p1,p2)
  ## *reduced* latitude:
  b1 <- atan((1-f)*tan(p1[1]))
  b2 <- atan((1-f)*tan(p2[1]))

  P <- (b1+b2)/2
  Q <- (b1-b2)/2
  X <- (s-sin(s))* (sin(P)*cos(Q)/cos(s/2))^2
  Y <- (s+sin(s))* (cos(P)*sin(Q)/sin(s/2))^2

  return(s-f*(X+Y)/2)
}

vincenty <- function(p1,p2){ # p1 and p2 are point 1 and point 2, (geodetic) latitude and longitude

  a <- 6378137.0 # equatorial radius from WGS-84   (meters)
  f <- 1/298.257223563 #  WGS-84

  b <- (1-f)*a  # polar radius from WGS-84

  phi1 <- p1[1]  # latitude of p1
  L1 <- p1[2]    # longitude of p1

  phi2 <- p2[1]  # latitude of p2
  L2 <- p2[2]    # longitude of p2

  U1 <- atan((1-f)*tan(phi1))
  U2 <- atan((1-f)*tan(phi2))

  L <- L2-L1
  lambda <- L2-L1  

  for(i in 1:10){
    sinsig <- sqrt(
    (cos(U2)*sin(lambda))^2 + (cos(U1)*sin(U2)-sin(U1)*cos(U2)*cos(lambda))^2)
    cossig <- sin(U1)*sin(U2) + cos(U1)*cos(U2)*cos(lambda)
    sigma <- atan2(sinsig,cossig)

    alpha <- asin(cos(U1)*cos(U2)*sin(lambda)/sin(sigma))
    sigma_m <- acos(cos(sigma) - 2*sin(U1)*sin(U2)/cos(alpha)^2 )/2

    C <- (f/16)*cos(alpha)^2*(4+f*(4-3*cos(alpha)^2))

    lambda <- L - (1-C)*f*sin(alpha) * (sigma + C*sin(sigma)*(cos(2*sigma_m) + C*cos(sigma)*(-1+2*cos(2*sigma_m)^2)))
  #  dput(lambda)

  }
  
  u <- abs(  cos(alpha) * sqrt((a^2-b^2)/b^2)   )
  A <- 1 + u^2/16834*(4096 + u^2*(-768 + u^2*(320-175*u^2)))
  B <- u^2/1024*(256 + u^2*(-128+u^2*(74 - 47*u^2)))
  delta_sigma <- B*sin(sigma)*(cos(2*sigma_m) + B/4*(cos(sigma)*(-1+2*cos(2*sigma_m)^2) - (B/6) *cos(2*sigma_m)*(-3+4*sin(sigma)^2)*(-3+4*cos(2*sigma_m)^2)))
  s <- b*A*(sigma - delta_sigma)

  alpha1 <- atan2(cos(U2)*sin(lambda), +cos(U1)*sin(U2)-sin(U1)*cos(U2)*cos(lambda))
  alpha2 <- atan2(cos(U1)*sin(lambda), -sin(U1)*cos(U2)+cos(U1)*sin(U2)*cos(lambda))
  return(c(alpha1,alpha2,s))
}
```


```{r}
lamb <- c(
 lambert_distance(RH,EC),
 lambert_distance(RH,LO),
lambert_distance(EC,LO))
names(lamb) <- c("RH_EC","RH_LO","EC_LO")
lamb
gc_dist
lamb - gc_dist
```


```{r}

vincenty(RH,LO)[1]
vincenty(RH,EC)[1]
angles_gcd <- angles
angles_gcd
angles_lamb <- c(
  vincenty(RH,LO)[1]-vincenty(RH,EC)[1],
  vincenty(LO,EC)[1]-vincenty(LO,RH)[1],
  vincenty(EC,LO)[1]-vincenty(EC,RH)[1])
angles_lamb

angles_lamb - angles_gcd

```
